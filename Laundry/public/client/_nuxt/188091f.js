(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{590:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/@firebase/app/dist/index.esm.js\nvar index_esm = __webpack_require__(412);\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(436);\n\n// EXTERNAL MODULE: ./node_modules/@firebase/component/dist/index.esm.js\nvar dist_index_esm = __webpack_require__(459);\n\n// CONCATENATED MODULE: ./node_modules/@firebase/functions/dist/index.esm.js\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Standard error codes for different ways a request can fail, as defined by:\r\n * https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\r\n *\r\n * This map is used primarily to convert from a backend error code string to\r\n * a client SDK error code string, and make sure it's in the supported set.\r\n */\r\nvar errorCodeMap = {\r\n    OK: 'ok',\r\n    CANCELLED: 'cancelled',\r\n    UNKNOWN: 'unknown',\r\n    INVALID_ARGUMENT: 'invalid-argument',\r\n    DEADLINE_EXCEEDED: 'deadline-exceeded',\r\n    NOT_FOUND: 'not-found',\r\n    ALREADY_EXISTS: 'already-exists',\r\n    PERMISSION_DENIED: 'permission-denied',\r\n    UNAUTHENTICATED: 'unauthenticated',\r\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\r\n    FAILED_PRECONDITION: 'failed-precondition',\r\n    ABORTED: 'aborted',\r\n    OUT_OF_RANGE: 'out-of-range',\r\n    UNIMPLEMENTED: 'unimplemented',\r\n    INTERNAL: 'internal',\r\n    UNAVAILABLE: 'unavailable',\r\n    DATA_LOSS: 'data-loss'\r\n};\r\n/**\r\n * An explicit error that can be thrown from a handler to send an error to the\r\n * client that called the function.\r\n */\r\nvar index_esm_HttpsErrorImpl = /** @class */ (function (_super) {\r\n    Object(tslib_es6[\"c\" /* __extends */])(HttpsErrorImpl, _super);\r\n    function HttpsErrorImpl(code, message, details) {\r\n        var _this = _super.call(this, message) || this;\r\n        // This is a workaround for a bug in TypeScript when extending Error:\r\n        // tslint:disable-next-line\r\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(_this, HttpsErrorImpl.prototype);\r\n        _this.code = code;\r\n        _this.details = details;\r\n        return _this;\r\n    }\r\n    return HttpsErrorImpl;\r\n}(Error));\r\n/**\r\n * Takes an HTTP status code and returns the corresponding ErrorCode.\r\n * This is the standard HTTP status code -> error mapping defined in:\r\n * https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\r\n *\r\n * @param status An HTTP status code.\r\n * @return The corresponding ErrorCode, or ErrorCode.UNKNOWN if none.\r\n */\r\nfunction codeForHTTPStatus(status) {\r\n    // Make sure any successful status is OK.\r\n    if (status >= 200 && status < 300) {\r\n        return 'ok';\r\n    }\r\n    switch (status) {\r\n        case 0:\r\n            // This can happen if the server returns 500.\r\n            return 'internal';\r\n        case 400:\r\n            return 'invalid-argument';\r\n        case 401:\r\n            return 'unauthenticated';\r\n        case 403:\r\n            return 'permission-denied';\r\n        case 404:\r\n            return 'not-found';\r\n        case 409:\r\n            return 'aborted';\r\n        case 429:\r\n            return 'resource-exhausted';\r\n        case 499:\r\n            return 'cancelled';\r\n        case 500:\r\n            return 'internal';\r\n        case 501:\r\n            return 'unimplemented';\r\n        case 503:\r\n            return 'unavailable';\r\n        case 504:\r\n            return 'deadline-exceeded';\r\n    }\r\n    return 'unknown';\r\n}\r\n/**\r\n * Takes an HTTP response and returns the corresponding Error, if any.\r\n */\r\nfunction _errorForResponse(status, bodyJSON, serializer) {\r\n    var code = codeForHTTPStatus(status);\r\n    // Start with reasonable defaults from the status code.\r\n    var description = code;\r\n    var details = undefined;\r\n    // Then look through the body for explicit details.\r\n    try {\r\n        var errorJSON = bodyJSON && bodyJSON.error;\r\n        if (errorJSON) {\r\n            var status_1 = errorJSON.status;\r\n            if (typeof status_1 === 'string') {\r\n                if (!errorCodeMap[status_1]) {\r\n                    // They must've included an unknown error code in the body.\r\n                    return new index_esm_HttpsErrorImpl('internal', 'internal');\r\n                }\r\n                code = errorCodeMap[status_1];\r\n                // TODO(klimt): Add better default descriptions for error enums.\r\n                // The default description needs to be updated for the new code.\r\n                description = status_1;\r\n            }\r\n            var message = errorJSON.message;\r\n            if (typeof message === 'string') {\r\n                description = message;\r\n            }\r\n            details = errorJSON.details;\r\n            if (details !== undefined) {\r\n                details = serializer.decode(details);\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        // If we couldn't parse explicit error data, that's fine.\r\n    }\r\n    if (code === 'ok') {\r\n        // Technically, there's an edge case where a developer could explicitly\r\n        // return an error code of OK, and we will treat it as success, but that\r\n        // seems reasonable.\r\n        return null;\r\n    }\r\n    return new index_esm_HttpsErrorImpl(code, description, details);\r\n}\n\n/**\r\n * Helper class to get metadata that should be included with a function call.\r\n */\r\nvar index_esm_ContextProvider = /** @class */ (function () {\r\n    function ContextProvider(authProvider, messagingProvider) {\r\n        var _this = this;\r\n        this.auth = null;\r\n        this.messaging = null;\r\n        this.auth = authProvider.getImmediate({ optional: true });\r\n        this.messaging = messagingProvider.getImmediate({\r\n            optional: true\r\n        });\r\n        if (!this.auth) {\r\n            authProvider.get().then(function (auth) { return (_this.auth = auth); }, function () {\r\n                /* get() never rejects */\r\n            });\r\n        }\r\n        if (!this.messaging) {\r\n            messagingProvider.get().then(function (messaging) { return (_this.messaging = messaging); }, function () {\r\n                /* get() never rejects */\r\n            });\r\n        }\r\n    }\r\n    ContextProvider.prototype.getAuthToken = function () {\r\n        return Object(tslib_es6[\"b\" /* __awaiter */])(this, void 0, void 0, function () {\r\n            var token, e_1;\r\n            return Object(tslib_es6[\"d\" /* __generator */])(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!this.auth) {\r\n                            return [2 /*return*/, undefined];\r\n                        }\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.auth.getToken()];\r\n                    case 2:\r\n                        token = _a.sent();\r\n                        if (!token) {\r\n                            return [2 /*return*/, undefined];\r\n                        }\r\n                        return [2 /*return*/, token.accessToken];\r\n                    case 3:\r\n                        e_1 = _a.sent();\r\n                        // If there's any error when trying to get the auth token, leave it off.\r\n                        return [2 /*return*/, undefined];\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ContextProvider.prototype.getInstanceIdToken = function () {\r\n        return Object(tslib_es6[\"b\" /* __awaiter */])(this, void 0, void 0, function () {\r\n            return Object(tslib_es6[\"d\" /* __generator */])(this, function (_a) {\r\n                if (!this.messaging ||\r\n                    !('Notification' in self) ||\r\n                    Notification.permission !== 'granted') {\r\n                    return [2 /*return*/, undefined];\r\n                }\r\n                try {\r\n                    return [2 /*return*/, this.messaging.getToken()];\r\n                }\r\n                catch (e) {\r\n                    // We don't warn on this, because it usually means messaging isn't set up.\r\n                    // console.warn('Failed to retrieve instance id token.', e);\r\n                    // If there's any error when trying to get the token, leave it off.\r\n                    return [2 /*return*/, undefined];\r\n                }\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    ContextProvider.prototype.getContext = function () {\r\n        return Object(tslib_es6[\"b\" /* __awaiter */])(this, void 0, void 0, function () {\r\n            var authToken, instanceIdToken;\r\n            return Object(tslib_es6[\"d\" /* __generator */])(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.getAuthToken()];\r\n                    case 1:\r\n                        authToken = _a.sent();\r\n                        return [4 /*yield*/, this.getInstanceIdToken()];\r\n                    case 2:\r\n                        instanceIdToken = _a.sent();\r\n                        return [2 /*return*/, { authToken: authToken, instanceIdToken: instanceIdToken }];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return ContextProvider;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar LONG_TYPE = 'type.googleapis.com/google.protobuf.Int64Value';\r\nvar UNSIGNED_LONG_TYPE = 'type.googleapis.com/google.protobuf.UInt64Value';\r\nfunction mapValues(\r\n// { [k: string]: unknown } is no longer a wildcard assignment target after typescript 3.5\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\no, f) {\r\n    var result = {};\r\n    for (var key in o) {\r\n        if (o.hasOwnProperty(key)) {\r\n            result[key] = f(o[key]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nvar Serializer = /** @class */ (function () {\r\n    function Serializer() {\r\n    }\r\n    // Takes data and encodes it in a JSON-friendly way, such that types such as\r\n    // Date are preserved.\r\n    Serializer.prototype.encode = function (data) {\r\n        var _this = this;\r\n        if (data == null) {\r\n            return null;\r\n        }\r\n        if (data instanceof Number) {\r\n            data = data.valueOf();\r\n        }\r\n        if (typeof data === 'number' && isFinite(data)) {\r\n            // Any number in JS is safe to put directly in JSON and parse as a double\r\n            // without any loss of precision.\r\n            return data;\r\n        }\r\n        if (data === true || data === false) {\r\n            return data;\r\n        }\r\n        if (Object.prototype.toString.call(data) === '[object String]') {\r\n            return data;\r\n        }\r\n        if (Array.isArray(data)) {\r\n            return data.map(function (x) { return _this.encode(x); });\r\n        }\r\n        if (typeof data === 'function' || typeof data === 'object') {\r\n            return mapValues(data, function (x) { return _this.encode(x); });\r\n        }\r\n        // If we got this far, the data is not encodable.\r\n        throw new Error('Data cannot be encoded in JSON: ' + data);\r\n    };\r\n    // Takes data that's been encoded in a JSON-friendly form and returns a form\r\n    // with richer datatypes, such as Dates, etc.\r\n    Serializer.prototype.decode = function (json) {\r\n        var _this = this;\r\n        if (json == null) {\r\n            return json;\r\n        }\r\n        if (json['@type']) {\r\n            switch (json['@type']) {\r\n                case LONG_TYPE:\r\n                // Fall through and handle this the same as unsigned.\r\n                case UNSIGNED_LONG_TYPE: {\r\n                    // Technically, this could work return a valid number for malformed\r\n                    // data if there was a number followed by garbage. But it's just not\r\n                    // worth all the extra code to detect that case.\r\n                    var value = Number(json['value']);\r\n                    if (isNaN(value)) {\r\n                        throw new Error('Data cannot be decoded from JSON: ' + json);\r\n                    }\r\n                    return value;\r\n                }\r\n                default: {\r\n                    throw new Error('Data cannot be decoded from JSON: ' + json);\r\n                }\r\n            }\r\n        }\r\n        if (Array.isArray(json)) {\r\n            return json.map(function (x) { return _this.decode(x); });\r\n        }\r\n        if (typeof json === 'function' || typeof json === 'object') {\r\n            return mapValues(json, function (x) { return _this.decode(x); });\r\n        }\r\n        // Anything else is safe to return.\r\n        return json;\r\n    };\r\n    return Serializer;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a Promise that will be rejected after the given duration.\r\n * The error will be of type HttpsErrorImpl.\r\n *\r\n * @param millis Number of milliseconds to wait before rejecting.\r\n */\r\nfunction failAfter(millis) {\r\n    var timer;\r\n    var promise = new Promise(function (_, reject) {\r\n        timer = setTimeout(function () {\r\n            reject(new index_esm_HttpsErrorImpl('deadline-exceeded', 'deadline-exceeded'));\r\n        }, millis);\r\n    });\r\n    return {\r\n        timer: timer,\r\n        promise: promise\r\n    };\r\n}\r\n/**\r\n * The main class for the Firebase Functions SDK.\r\n */\r\nvar index_esm_Service = /** @class */ (function () {\r\n    /**\r\n     * Creates a new Functions service for the given app and (optional) region or custom domain.\r\n     * @param app_ The FirebaseApp to use.\r\n     * @param regionOrCustomDomain_ one of:\r\n     *   a) A region to call functions from, such as us-central1\r\n     *   b) A custom domain to use as a functions prefix, such as https://mydomain.com\r\n     */\r\n    function Service(app_, authProvider, messagingProvider, regionOrCustomDomain_, fetchImpl) {\r\n        var _this = this;\r\n        if (regionOrCustomDomain_ === void 0) { regionOrCustomDomain_ = 'us-central1'; }\r\n        this.app_ = app_;\r\n        this.fetchImpl = fetchImpl;\r\n        this.serializer = new Serializer();\r\n        this.emulatorOrigin = null;\r\n        this.INTERNAL = {\r\n            delete: function () {\r\n                return Promise.resolve(_this.deleteService());\r\n            }\r\n        };\r\n        this.contextProvider = new index_esm_ContextProvider(authProvider, messagingProvider);\r\n        // Cancels all ongoing requests when resolved.\r\n        this.cancelAllRequests = new Promise(function (resolve) {\r\n            _this.deleteService = function () {\r\n                return resolve();\r\n            };\r\n        });\r\n        // Resolve the region or custom domain overload by attempting to parse it.\r\n        try {\r\n            var url = new URL(regionOrCustomDomain_);\r\n            this.customDomain = url.origin;\r\n            this.region = 'us-central1';\r\n        }\r\n        catch (e) {\r\n            this.customDomain = null;\r\n            this.region = regionOrCustomDomain_;\r\n        }\r\n    }\r\n    Object.defineProperty(Service.prototype, \"app\", {\r\n        get: function () {\r\n            return this.app_;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns the URL for a callable with the given name.\r\n     * @param name The name of the callable.\r\n     */\r\n    Service.prototype._url = function (name) {\r\n        var projectId = this.app_.options.projectId;\r\n        if (this.emulatorOrigin !== null) {\r\n            var origin_1 = this.emulatorOrigin;\r\n            return origin_1 + \"/\" + projectId + \"/\" + this.region + \"/\" + name;\r\n        }\r\n        if (this.customDomain !== null) {\r\n            return this.customDomain + \"/\" + name;\r\n        }\r\n        return \"https://\" + this.region + \"-\" + projectId + \".cloudfunctions.net/\" + name;\r\n    };\r\n    /**\r\n     * Modify this instance to communicate with the Cloud Functions emulator.\r\n     *\r\n     * Note: this must be called before this instance has been used to do any operations.\r\n     *\r\n     * @param host The emulator host (ex: localhost)\r\n     * @param port The emulator port (ex: 5001)\r\n     */\r\n    Service.prototype.useEmulator = function (host, port) {\r\n        this.emulatorOrigin = \"http://\" + host + \":\" + port;\r\n    };\r\n    /**\r\n     * Changes this instance to point to a Cloud Functions emulator running\r\n     * locally. See https://firebase.google.com/docs/functions/local-emulator\r\n     *\r\n     * @deprecated Prefer the useEmulator(host, port) method.\r\n     * @param origin The origin of the local emulator, such as\r\n     * \"http://localhost:5005\".\r\n     */\r\n    Service.prototype.useFunctionsEmulator = function (origin) {\r\n        this.emulatorOrigin = origin;\r\n    };\r\n    /**\r\n     * Returns a reference to the callable https trigger with the given name.\r\n     * @param name The name of the trigger.\r\n     */\r\n    Service.prototype.httpsCallable = function (name, options) {\r\n        var _this = this;\r\n        return function (data) {\r\n            return _this.call(name, data, options || {});\r\n        };\r\n    };\r\n    /**\r\n     * Does an HTTP POST and returns the completed response.\r\n     * @param url The url to post to.\r\n     * @param body The JSON body of the post.\r\n     * @param headers The HTTP headers to include in the request.\r\n     * @return A Promise that will succeed when the request finishes.\r\n     */\r\n    Service.prototype.postJSON = function (url, body, headers) {\r\n        return Object(tslib_es6[\"b\" /* __awaiter */])(this, void 0, void 0, function () {\r\n            var response, e_1, json, e_2;\r\n            return Object(tslib_es6[\"d\" /* __generator */])(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        headers['Content-Type'] = 'application/json';\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.fetchImpl(url, {\r\n                                method: 'POST',\r\n                                body: JSON.stringify(body),\r\n                                headers: headers\r\n                            })];\r\n                    case 2:\r\n                        response = _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        e_1 = _a.sent();\r\n                        // This could be an unhandled error on the backend, or it could be a\r\n                        // network error. There's no way to know, since an unhandled error on the\r\n                        // backend will fail to set the proper CORS header, and thus will be\r\n                        // treated as a network error by fetch.\r\n                        return [2 /*return*/, {\r\n                                status: 0,\r\n                                json: null\r\n                            }];\r\n                    case 4:\r\n                        json = null;\r\n                        _a.label = 5;\r\n                    case 5:\r\n                        _a.trys.push([5, 7, , 8]);\r\n                        return [4 /*yield*/, response.json()];\r\n                    case 6:\r\n                        json = _a.sent();\r\n                        return [3 /*break*/, 8];\r\n                    case 7:\r\n                        e_2 = _a.sent();\r\n                        return [3 /*break*/, 8];\r\n                    case 8: return [2 /*return*/, {\r\n                            status: response.status,\r\n                            json: json\r\n                        }];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Calls a callable function asynchronously and returns the result.\r\n     * @param name The name of the callable trigger.\r\n     * @param data The data to pass as params to the function.s\r\n     */\r\n    Service.prototype.call = function (name, data, options) {\r\n        return Object(tslib_es6[\"b\" /* __awaiter */])(this, void 0, void 0, function () {\r\n            var url, body, headers, context, timeout, _a, timer, failAfterPromise, response, error, responseData, decodedData;\r\n            return Object(tslib_es6[\"d\" /* __generator */])(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        url = this._url(name);\r\n                        // Encode any special types, such as dates, in the input data.\r\n                        data = this.serializer.encode(data);\r\n                        body = { data: data };\r\n                        headers = {};\r\n                        return [4 /*yield*/, this.contextProvider.getContext()];\r\n                    case 1:\r\n                        context = _b.sent();\r\n                        if (context.authToken) {\r\n                            headers['Authorization'] = 'Bearer ' + context.authToken;\r\n                        }\r\n                        if (context.instanceIdToken) {\r\n                            headers['Firebase-Instance-ID-Token'] = context.instanceIdToken;\r\n                        }\r\n                        timeout = options.timeout || 70000;\r\n                        _a = failAfter(timeout), timer = _a.timer, failAfterPromise = _a.promise;\r\n                        return [4 /*yield*/, Promise.race([\r\n                                clearTimeoutWrapper(timer, this.postJSON(url, body, headers)),\r\n                                failAfterPromise,\r\n                                clearTimeoutWrapper(timer, this.cancelAllRequests)\r\n                            ])];\r\n                    case 2:\r\n                        response = _b.sent();\r\n                        // If service was deleted, interrupted response throws an error.\r\n                        if (!response) {\r\n                            throw new index_esm_HttpsErrorImpl('cancelled', 'Firebase Functions instance was deleted.');\r\n                        }\r\n                        error = _errorForResponse(response.status, response.json, this.serializer);\r\n                        if (error) {\r\n                            throw error;\r\n                        }\r\n                        if (!response.json) {\r\n                            throw new index_esm_HttpsErrorImpl('internal', 'Response is not valid JSON object.');\r\n                        }\r\n                        responseData = response.json.data;\r\n                        // TODO(klimt): For right now, allow \"result\" instead of \"data\", for\r\n                        // backwards compatibility.\r\n                        if (typeof responseData === 'undefined') {\r\n                            responseData = response.json.result;\r\n                        }\r\n                        if (typeof responseData === 'undefined') {\r\n                            // Consider the response malformed.\r\n                            throw new index_esm_HttpsErrorImpl('internal', 'Response is missing data field.');\r\n                        }\r\n                        decodedData = this.serializer.decode(responseData);\r\n                        return [2 /*return*/, { data: decodedData }];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return Service;\r\n}());\r\nfunction clearTimeoutWrapper(timer, promise) {\r\n    return Object(tslib_es6[\"b\" /* __awaiter */])(this, void 0, void 0, function () {\r\n        var result;\r\n        return Object(tslib_es6[\"d\" /* __generator */])(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, promise];\r\n                case 1:\r\n                    result = _a.sent();\r\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                    clearTimeout(timer);\r\n                    return [2 /*return*/, result];\r\n            }\r\n        });\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Type constant for Firebase Functions.\r\n */\r\nvar FUNCTIONS_TYPE = 'functions';\r\nfunction registerFunctions(instance, fetchImpl) {\r\n    var namespaceExports = {\r\n        // no-inline\r\n        Functions: index_esm_Service\r\n    };\r\n    function factory(container, regionOrCustomDomain) {\r\n        // Dependencies\r\n        var app = container.getProvider('app').getImmediate();\r\n        var authProvider = container.getProvider('auth-internal');\r\n        var messagingProvider = container.getProvider('messaging');\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return new index_esm_Service(app, authProvider, messagingProvider, regionOrCustomDomain, fetchImpl);\r\n    }\r\n    instance.INTERNAL.registerComponent(new dist_index_esm[\"a\" /* Component */](FUNCTIONS_TYPE, factory, \"PUBLIC\" /* PUBLIC */)\r\n        .setServiceProps(namespaceExports)\r\n        .setMultipleInstances(true));\r\n}\n\nvar index_esm_name = \"@firebase/functions\";\nvar version = \"0.6.1\";\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nregisterFunctions(index_esm[\"a\" /* default */], fetch.bind(self));\r\nindex_esm[\"a\" /* default */].registerVersion(index_esm_name, version);\n//# sourceMappingURL=index.esm.js.map\n\n// CONCATENATED MODULE: ./node_modules/firebase/functions/dist/index.esm.js\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2Z1bmN0aW9ucy9kaXN0L2luZGV4LmVzbS5qcz83ZGM3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9mdW5jdGlvbnMvZGlzdC9pbmRleC5lc20uanM/ODkzNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ3FCO0FBQ1Y7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBYztBQUNsQixJQUFJLHNDQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3QkFBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LHNDQUFzQyx3QkFBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0JBQWM7QUFDcEQ7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0I7QUFDbkU7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxXQUFXLHNDQUFTO0FBQ3BCO0FBQ0EsZUFBZSx3Q0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFPO0FBQzFCO0FBQ0EsNENBQTRDLG1DQUFTO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGNBQUk7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBUTtBQUMxQiw0QkFBUSxpQkFBaUIsY0FBSTtBQUM3Qjs7O0FDenBCNkI7QUFDN0IiLCJmaWxlIjoiNTkwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZpcmViYXNlIGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgX19leHRlbmRzLCBfX2F3YWl0ZXIsIF9fZ2VuZXJhdG9yIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBTdGFuZGFyZCBlcnJvciBjb2RlcyBmb3IgZGlmZmVyZW50IHdheXMgYSByZXF1ZXN0IGNhbiBmYWlsLCBhcyBkZWZpbmVkIGJ5OlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlYXBpcy9nb29nbGVhcGlzL2Jsb2IvbWFzdGVyL2dvb2dsZS9ycGMvY29kZS5wcm90b1xyXG4gKlxyXG4gKiBUaGlzIG1hcCBpcyB1c2VkIHByaW1hcmlseSB0byBjb252ZXJ0IGZyb20gYSBiYWNrZW5kIGVycm9yIGNvZGUgc3RyaW5nIHRvXHJcbiAqIGEgY2xpZW50IFNESyBlcnJvciBjb2RlIHN0cmluZywgYW5kIG1ha2Ugc3VyZSBpdCdzIGluIHRoZSBzdXBwb3J0ZWQgc2V0LlxyXG4gKi9cclxudmFyIGVycm9yQ29kZU1hcCA9IHtcclxuICAgIE9LOiAnb2snLFxyXG4gICAgQ0FOQ0VMTEVEOiAnY2FuY2VsbGVkJyxcclxuICAgIFVOS05PV046ICd1bmtub3duJyxcclxuICAgIElOVkFMSURfQVJHVU1FTlQ6ICdpbnZhbGlkLWFyZ3VtZW50JyxcclxuICAgIERFQURMSU5FX0VYQ0VFREVEOiAnZGVhZGxpbmUtZXhjZWVkZWQnLFxyXG4gICAgTk9UX0ZPVU5EOiAnbm90LWZvdW5kJyxcclxuICAgIEFMUkVBRFlfRVhJU1RTOiAnYWxyZWFkeS1leGlzdHMnLFxyXG4gICAgUEVSTUlTU0lPTl9ERU5JRUQ6ICdwZXJtaXNzaW9uLWRlbmllZCcsXHJcbiAgICBVTkFVVEhFTlRJQ0FURUQ6ICd1bmF1dGhlbnRpY2F0ZWQnLFxyXG4gICAgUkVTT1VSQ0VfRVhIQVVTVEVEOiAncmVzb3VyY2UtZXhoYXVzdGVkJyxcclxuICAgIEZBSUxFRF9QUkVDT05ESVRJT046ICdmYWlsZWQtcHJlY29uZGl0aW9uJyxcclxuICAgIEFCT1JURUQ6ICdhYm9ydGVkJyxcclxuICAgIE9VVF9PRl9SQU5HRTogJ291dC1vZi1yYW5nZScsXHJcbiAgICBVTklNUExFTUVOVEVEOiAndW5pbXBsZW1lbnRlZCcsXHJcbiAgICBJTlRFUk5BTDogJ2ludGVybmFsJyxcclxuICAgIFVOQVZBSUxBQkxFOiAndW5hdmFpbGFibGUnLFxyXG4gICAgREFUQV9MT1NTOiAnZGF0YS1sb3NzJ1xyXG59O1xyXG4vKipcclxuICogQW4gZXhwbGljaXQgZXJyb3IgdGhhdCBjYW4gYmUgdGhyb3duIGZyb20gYSBoYW5kbGVyIHRvIHNlbmQgYW4gZXJyb3IgdG8gdGhlXHJcbiAqIGNsaWVudCB0aGF0IGNhbGxlZCB0aGUgZnVuY3Rpb24uXHJcbiAqL1xyXG52YXIgSHR0cHNFcnJvckltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSHR0cHNFcnJvckltcGwsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBIdHRwc0Vycm9ySW1wbChjb2RlLCBtZXNzYWdlLCBkZXRhaWxzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcclxuICAgICAgICAvLyBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gVHlwZVNjcmlwdCB3aGVuIGV4dGVuZGluZyBFcnJvcjpcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQtd2lraS9ibG9iL21hc3Rlci9CcmVha2luZy1DaGFuZ2VzLm1kI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29ya1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgSHR0cHNFcnJvckltcGwucHJvdG90eXBlKTtcclxuICAgICAgICBfdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICBfdGhpcy5kZXRhaWxzID0gZGV0YWlscztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSHR0cHNFcnJvckltcGw7XHJcbn0oRXJyb3IpKTtcclxuLyoqXHJcbiAqIFRha2VzIGFuIEhUVFAgc3RhdHVzIGNvZGUgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgRXJyb3JDb2RlLlxyXG4gKiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBIVFRQIHN0YXR1cyBjb2RlIC0+IGVycm9yIG1hcHBpbmcgZGVmaW5lZCBpbjpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFwaXMvZ29vZ2xlYXBpcy9ibG9iL21hc3Rlci9nb29nbGUvcnBjL2NvZGUucHJvdG9cclxuICpcclxuICogQHBhcmFtIHN0YXR1cyBBbiBIVFRQIHN0YXR1cyBjb2RlLlxyXG4gKiBAcmV0dXJuIFRoZSBjb3JyZXNwb25kaW5nIEVycm9yQ29kZSwgb3IgRXJyb3JDb2RlLlVOS05PV04gaWYgbm9uZS5cclxuICovXHJcbmZ1bmN0aW9uIGNvZGVGb3JIVFRQU3RhdHVzKHN0YXR1cykge1xyXG4gICAgLy8gTWFrZSBzdXJlIGFueSBzdWNjZXNzZnVsIHN0YXR1cyBpcyBPSy5cclxuICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCkge1xyXG4gICAgICAgIHJldHVybiAnb2snO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChzdGF0dXMpIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgc2VydmVyIHJldHVybnMgNTAwLlxyXG4gICAgICAgICAgICByZXR1cm4gJ2ludGVybmFsJztcclxuICAgICAgICBjYXNlIDQwMDpcclxuICAgICAgICAgICAgcmV0dXJuICdpbnZhbGlkLWFyZ3VtZW50JztcclxuICAgICAgICBjYXNlIDQwMTpcclxuICAgICAgICAgICAgcmV0dXJuICd1bmF1dGhlbnRpY2F0ZWQnO1xyXG4gICAgICAgIGNhc2UgNDAzOlxyXG4gICAgICAgICAgICByZXR1cm4gJ3Blcm1pc3Npb24tZGVuaWVkJztcclxuICAgICAgICBjYXNlIDQwNDpcclxuICAgICAgICAgICAgcmV0dXJuICdub3QtZm91bmQnO1xyXG4gICAgICAgIGNhc2UgNDA5OlxyXG4gICAgICAgICAgICByZXR1cm4gJ2Fib3J0ZWQnO1xyXG4gICAgICAgIGNhc2UgNDI5OlxyXG4gICAgICAgICAgICByZXR1cm4gJ3Jlc291cmNlLWV4aGF1c3RlZCc7XHJcbiAgICAgICAgY2FzZSA0OTk6XHJcbiAgICAgICAgICAgIHJldHVybiAnY2FuY2VsbGVkJztcclxuICAgICAgICBjYXNlIDUwMDpcclxuICAgICAgICAgICAgcmV0dXJuICdpbnRlcm5hbCc7XHJcbiAgICAgICAgY2FzZSA1MDE6XHJcbiAgICAgICAgICAgIHJldHVybiAndW5pbXBsZW1lbnRlZCc7XHJcbiAgICAgICAgY2FzZSA1MDM6XHJcbiAgICAgICAgICAgIHJldHVybiAndW5hdmFpbGFibGUnO1xyXG4gICAgICAgIGNhc2UgNTA0OlxyXG4gICAgICAgICAgICByZXR1cm4gJ2RlYWRsaW5lLWV4Y2VlZGVkJztcclxuICAgIH1cclxuICAgIHJldHVybiAndW5rbm93bic7XHJcbn1cclxuLyoqXHJcbiAqIFRha2VzIGFuIEhUVFAgcmVzcG9uc2UgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgRXJyb3IsIGlmIGFueS5cclxuICovXHJcbmZ1bmN0aW9uIF9lcnJvckZvclJlc3BvbnNlKHN0YXR1cywgYm9keUpTT04sIHNlcmlhbGl6ZXIpIHtcclxuICAgIHZhciBjb2RlID0gY29kZUZvckhUVFBTdGF0dXMoc3RhdHVzKTtcclxuICAgIC8vIFN0YXJ0IHdpdGggcmVhc29uYWJsZSBkZWZhdWx0cyBmcm9tIHRoZSBzdGF0dXMgY29kZS5cclxuICAgIHZhciBkZXNjcmlwdGlvbiA9IGNvZGU7XHJcbiAgICB2YXIgZGV0YWlscyA9IHVuZGVmaW5lZDtcclxuICAgIC8vIFRoZW4gbG9vayB0aHJvdWdoIHRoZSBib2R5IGZvciBleHBsaWNpdCBkZXRhaWxzLlxyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgZXJyb3JKU09OID0gYm9keUpTT04gJiYgYm9keUpTT04uZXJyb3I7XHJcbiAgICAgICAgaWYgKGVycm9ySlNPTikge1xyXG4gICAgICAgICAgICB2YXIgc3RhdHVzXzEgPSBlcnJvckpTT04uc3RhdHVzO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXR1c18xID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvckNvZGVNYXBbc3RhdHVzXzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhleSBtdXN0J3ZlIGluY2x1ZGVkIGFuIHVua25vd24gZXJyb3IgY29kZSBpbiB0aGUgYm9keS5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEh0dHBzRXJyb3JJbXBsKCdpbnRlcm5hbCcsICdpbnRlcm5hbCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29kZSA9IGVycm9yQ29kZU1hcFtzdGF0dXNfMV07XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGtsaW10KTogQWRkIGJldHRlciBkZWZhdWx0IGRlc2NyaXB0aW9ucyBmb3IgZXJyb3IgZW51bXMuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBkZXNjcmlwdGlvbiBuZWVkcyB0byBiZSB1cGRhdGVkIGZvciB0aGUgbmV3IGNvZGUuXHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9IHN0YXR1c18xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXJyb3JKU09OLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gbWVzc2FnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZXRhaWxzID0gZXJyb3JKU09OLmRldGFpbHM7XHJcbiAgICAgICAgICAgIGlmIChkZXRhaWxzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRldGFpbHMgPSBzZXJpYWxpemVyLmRlY29kZShkZXRhaWxzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gSWYgd2UgY291bGRuJ3QgcGFyc2UgZXhwbGljaXQgZXJyb3IgZGF0YSwgdGhhdCdzIGZpbmUuXHJcbiAgICB9XHJcbiAgICBpZiAoY29kZSA9PT0gJ29rJykge1xyXG4gICAgICAgIC8vIFRlY2huaWNhbGx5LCB0aGVyZSdzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGRldmVsb3BlciBjb3VsZCBleHBsaWNpdGx5XHJcbiAgICAgICAgLy8gcmV0dXJuIGFuIGVycm9yIGNvZGUgb2YgT0ssIGFuZCB3ZSB3aWxsIHRyZWF0IGl0IGFzIHN1Y2Nlc3MsIGJ1dCB0aGF0XHJcbiAgICAgICAgLy8gc2VlbXMgcmVhc29uYWJsZS5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgSHR0cHNFcnJvckltcGwoY29kZSwgZGVzY3JpcHRpb24sIGRldGFpbHMpO1xyXG59XG5cbi8qKlxyXG4gKiBIZWxwZXIgY2xhc3MgdG8gZ2V0IG1ldGFkYXRhIHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkIHdpdGggYSBmdW5jdGlvbiBjYWxsLlxyXG4gKi9cclxudmFyIENvbnRleHRQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbnRleHRQcm92aWRlcihhdXRoUHJvdmlkZXIsIG1lc3NhZ2luZ1Byb3ZpZGVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmF1dGggPSBudWxsO1xyXG4gICAgICAgIHRoaXMubWVzc2FnaW5nID0gbnVsbDtcclxuICAgICAgICB0aGlzLmF1dGggPSBhdXRoUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdpbmcgPSBtZXNzYWdpbmdQcm92aWRlci5nZXRJbW1lZGlhdGUoe1xyXG4gICAgICAgICAgICBvcHRpb25hbDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghdGhpcy5hdXRoKSB7XHJcbiAgICAgICAgICAgIGF1dGhQcm92aWRlci5nZXQoKS50aGVuKGZ1bmN0aW9uIChhdXRoKSB7IHJldHVybiAoX3RoaXMuYXV0aCA9IGF1dGgpOyB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBnZXQoKSBuZXZlciByZWplY3RzICovXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMubWVzc2FnaW5nKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2luZ1Byb3ZpZGVyLmdldCgpLnRoZW4oZnVuY3Rpb24gKG1lc3NhZ2luZykgeyByZXR1cm4gKF90aGlzLm1lc3NhZ2luZyA9IG1lc3NhZ2luZyk7IH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8qIGdldCgpIG5ldmVyIHJlamVjdHMgKi9cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgQ29udGV4dFByb3ZpZGVyLnByb3RvdHlwZS5nZXRBdXRoVG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdG9rZW4sIGVfMTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF1dGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuYXV0aC5nZXRUb2tlbigpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdW5kZWZpbmVkXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdG9rZW4uYWNjZXNzVG9rZW5dO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFueSBlcnJvciB3aGVuIHRyeWluZyB0byBnZXQgdGhlIGF1dGggdG9rZW4sIGxlYXZlIGl0IG9mZi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENvbnRleHRQcm92aWRlci5wcm90b3R5cGUuZ2V0SW5zdGFuY2VJZFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1lc3NhZ2luZyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICEoJ05vdGlmaWNhdGlvbicgaW4gc2VsZikgfHxcclxuICAgICAgICAgICAgICAgICAgICBOb3RpZmljYXRpb24ucGVybWlzc2lvbiAhPT0gJ2dyYW50ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLm1lc3NhZ2luZy5nZXRUb2tlbigpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FybiBvbiB0aGlzLCBiZWNhdXNlIGl0IHVzdWFsbHkgbWVhbnMgbWVzc2FnaW5nIGlzbid0IHNldCB1cC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byByZXRyaWV2ZSBpbnN0YW5jZSBpZCB0b2tlbi4nLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFueSBlcnJvciB3aGVuIHRyeWluZyB0byBnZXQgdGhlIHRva2VuLCBsZWF2ZSBpdCBvZmYuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENvbnRleHRQcm92aWRlci5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhdXRoVG9rZW4sIGluc3RhbmNlSWRUb2tlbjtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRBdXRoVG9rZW4oKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoVG9rZW4gPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0SW5zdGFuY2VJZFRva2VuKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZFRva2VuID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgeyBhdXRoVG9rZW46IGF1dGhUb2tlbiwgaW5zdGFuY2VJZFRva2VuOiBpbnN0YW5jZUlkVG9rZW4gfV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb250ZXh0UHJvdmlkZXI7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBMT05HX1RZUEUgPSAndHlwZS5nb29nbGVhcGlzLmNvbS9nb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZSc7XHJcbnZhciBVTlNJR05FRF9MT05HX1RZUEUgPSAndHlwZS5nb29nbGVhcGlzLmNvbS9nb29nbGUucHJvdG9idWYuVUludDY0VmFsdWUnO1xyXG5mdW5jdGlvbiBtYXBWYWx1ZXMoXHJcbi8vIHsgW2s6IHN0cmluZ106IHVua25vd24gfSBpcyBubyBsb25nZXIgYSB3aWxkY2FyZCBhc3NpZ25tZW50IHRhcmdldCBhZnRlciB0eXBlc2NyaXB0IDMuNVxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5vLCBmKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gbykge1xyXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBmKG9ba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG52YXIgU2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNlcmlhbGl6ZXIoKSB7XHJcbiAgICB9XHJcbiAgICAvLyBUYWtlcyBkYXRhIGFuZCBlbmNvZGVzIGl0IGluIGEgSlNPTi1mcmllbmRseSB3YXksIHN1Y2ggdGhhdCB0eXBlcyBzdWNoIGFzXHJcbiAgICAvLyBEYXRlIGFyZSBwcmVzZXJ2ZWQuXHJcbiAgICBTZXJpYWxpemVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBOdW1iZXIpIHtcclxuICAgICAgICAgICAgZGF0YSA9IGRhdGEudmFsdWVPZigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmIGlzRmluaXRlKGRhdGEpKSB7XHJcbiAgICAgICAgICAgIC8vIEFueSBudW1iZXIgaW4gSlMgaXMgc2FmZSB0byBwdXQgZGlyZWN0bHkgaW4gSlNPTiBhbmQgcGFyc2UgYXMgYSBkb3VibGVcclxuICAgICAgICAgICAgLy8gd2l0aG91dCBhbnkgbG9zcyBvZiBwcmVjaXNpb24uXHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSB8fCBkYXRhID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gX3RoaXMuZW5jb2RlKHgpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFwVmFsdWVzKGRhdGEsIGZ1bmN0aW9uICh4KSB7IHJldHVybiBfdGhpcy5lbmNvZGUoeCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIsIHRoZSBkYXRhIGlzIG5vdCBlbmNvZGFibGUuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGNhbm5vdCBiZSBlbmNvZGVkIGluIEpTT046ICcgKyBkYXRhKTtcclxuICAgIH07XHJcbiAgICAvLyBUYWtlcyBkYXRhIHRoYXQncyBiZWVuIGVuY29kZWQgaW4gYSBKU09OLWZyaWVuZGx5IGZvcm0gYW5kIHJldHVybnMgYSBmb3JtXHJcbiAgICAvLyB3aXRoIHJpY2hlciBkYXRhdHlwZXMsIHN1Y2ggYXMgRGF0ZXMsIGV0Yy5cclxuICAgIFNlcmlhbGl6ZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChqc29uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoanNvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoanNvblsnQHR5cGUnXSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGpzb25bJ0B0eXBlJ10pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgTE9OR19UWVBFOlxyXG4gICAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoIGFuZCBoYW5kbGUgdGhpcyB0aGUgc2FtZSBhcyB1bnNpZ25lZC5cclxuICAgICAgICAgICAgICAgIGNhc2UgVU5TSUdORURfTE9OR19UWVBFOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGVjaG5pY2FsbHksIHRoaXMgY291bGQgd29yayByZXR1cm4gYSB2YWxpZCBudW1iZXIgZm9yIG1hbGZvcm1lZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRhdGEgaWYgdGhlcmUgd2FzIGEgbnVtYmVyIGZvbGxvd2VkIGJ5IGdhcmJhZ2UuIEJ1dCBpdCdzIGp1c3Qgbm90XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd29ydGggYWxsIHRoZSBleHRyYSBjb2RlIHRvIGRldGVjdCB0aGF0IGNhc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKGpzb25bJ3ZhbHVlJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGNhbm5vdCBiZSBkZWNvZGVkIGZyb20gSlNPTjogJyArIGpzb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGNhbm5vdCBiZSBkZWNvZGVkIGZyb20gSlNPTjogJyArIGpzb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gX3RoaXMuZGVjb2RlKHgpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBqc29uID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFwVmFsdWVzKGpzb24sIGZ1bmN0aW9uICh4KSB7IHJldHVybiBfdGhpcy5kZWNvZGUoeCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBbnl0aGluZyBlbHNlIGlzIHNhZmUgdG8gcmV0dXJuLlxyXG4gICAgICAgIHJldHVybiBqc29uO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTZXJpYWxpemVyO1xyXG59KCkpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBhIFByb21pc2UgdGhhdCB3aWxsIGJlIHJlamVjdGVkIGFmdGVyIHRoZSBnaXZlbiBkdXJhdGlvbi5cclxuICogVGhlIGVycm9yIHdpbGwgYmUgb2YgdHlwZSBIdHRwc0Vycm9ySW1wbC5cclxuICpcclxuICogQHBhcmFtIG1pbGxpcyBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJlamVjdGluZy5cclxuICovXHJcbmZ1bmN0aW9uIGZhaWxBZnRlcihtaWxsaXMpIHtcclxuICAgIHZhciB0aW1lcjtcclxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xyXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChuZXcgSHR0cHNFcnJvckltcGwoJ2RlYWRsaW5lLWV4Y2VlZGVkJywgJ2RlYWRsaW5lLWV4Y2VlZGVkJykpO1xyXG4gICAgICAgIH0sIG1pbGxpcyk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdGltZXI6IHRpbWVyLFxyXG4gICAgICAgIHByb21pc2U6IHByb21pc2VcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBtYWluIGNsYXNzIGZvciB0aGUgRmlyZWJhc2UgRnVuY3Rpb25zIFNESy5cclxuICovXHJcbnZhciBTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZ1bmN0aW9ucyBzZXJ2aWNlIGZvciB0aGUgZ2l2ZW4gYXBwIGFuZCAob3B0aW9uYWwpIHJlZ2lvbiBvciBjdXN0b20gZG9tYWluLlxyXG4gICAgICogQHBhcmFtIGFwcF8gVGhlIEZpcmViYXNlQXBwIHRvIHVzZS5cclxuICAgICAqIEBwYXJhbSByZWdpb25PckN1c3RvbURvbWFpbl8gb25lIG9mOlxyXG4gICAgICogICBhKSBBIHJlZ2lvbiB0byBjYWxsIGZ1bmN0aW9ucyBmcm9tLCBzdWNoIGFzIHVzLWNlbnRyYWwxXHJcbiAgICAgKiAgIGIpIEEgY3VzdG9tIGRvbWFpbiB0byB1c2UgYXMgYSBmdW5jdGlvbnMgcHJlZml4LCBzdWNoIGFzIGh0dHBzOi8vbXlkb21haW4uY29tXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNlcnZpY2UoYXBwXywgYXV0aFByb3ZpZGVyLCBtZXNzYWdpbmdQcm92aWRlciwgcmVnaW9uT3JDdXN0b21Eb21haW5fLCBmZXRjaEltcGwpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChyZWdpb25PckN1c3RvbURvbWFpbl8gPT09IHZvaWQgMCkgeyByZWdpb25PckN1c3RvbURvbWFpbl8gPSAndXMtY2VudHJhbDEnOyB9XHJcbiAgICAgICAgdGhpcy5hcHBfID0gYXBwXztcclxuICAgICAgICB0aGlzLmZldGNoSW1wbCA9IGZldGNoSW1wbDtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBuZXcgU2VyaWFsaXplcigpO1xyXG4gICAgICAgIHRoaXMuZW11bGF0b3JPcmlnaW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuSU5URVJOQUwgPSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGhpcy5kZWxldGVTZXJ2aWNlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmNvbnRleHRQcm92aWRlciA9IG5ldyBDb250ZXh0UHJvdmlkZXIoYXV0aFByb3ZpZGVyLCBtZXNzYWdpbmdQcm92aWRlcik7XHJcbiAgICAgICAgLy8gQ2FuY2VscyBhbGwgb25nb2luZyByZXF1ZXN0cyB3aGVuIHJlc29sdmVkLlxyXG4gICAgICAgIHRoaXMuY2FuY2VsQWxsUmVxdWVzdHMgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5kZWxldGVTZXJ2aWNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBSZXNvbHZlIHRoZSByZWdpb24gb3IgY3VzdG9tIGRvbWFpbiBvdmVybG9hZCBieSBhdHRlbXB0aW5nIHRvIHBhcnNlIGl0LlxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwgPSBuZXcgVVJMKHJlZ2lvbk9yQ3VzdG9tRG9tYWluXyk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tRG9tYWluID0gdXJsLm9yaWdpbjtcclxuICAgICAgICAgICAgdGhpcy5yZWdpb24gPSAndXMtY2VudHJhbDEnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1c3RvbURvbWFpbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaW9uID0gcmVnaW9uT3JDdXN0b21Eb21haW5fO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlLnByb3RvdHlwZSwgXCJhcHBcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBfO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgVVJMIGZvciBhIGNhbGxhYmxlIHdpdGggdGhlIGdpdmVuIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY2FsbGFibGUuXHJcbiAgICAgKi9cclxuICAgIFNlcnZpY2UucHJvdG90eXBlLl91cmwgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBwcm9qZWN0SWQgPSB0aGlzLmFwcF8ub3B0aW9ucy5wcm9qZWN0SWQ7XHJcbiAgICAgICAgaWYgKHRoaXMuZW11bGF0b3JPcmlnaW4gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIG9yaWdpbl8xID0gdGhpcy5lbXVsYXRvck9yaWdpbjtcclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbl8xICsgXCIvXCIgKyBwcm9qZWN0SWQgKyBcIi9cIiArIHRoaXMucmVnaW9uICsgXCIvXCIgKyBuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXN0b21Eb21haW4gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tRG9tYWluICsgXCIvXCIgKyBuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJodHRwczovL1wiICsgdGhpcy5yZWdpb24gKyBcIi1cIiArIHByb2plY3RJZCArIFwiLmNsb3VkZnVuY3Rpb25zLm5ldC9cIiArIG5hbWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RpZnkgdGhpcyBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBDbG91ZCBGdW5jdGlvbnMgZW11bGF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogdGhpcyBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgdGhpcyBpbnN0YW5jZSBoYXMgYmVlbiB1c2VkIHRvIGRvIGFueSBvcGVyYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBob3N0IFRoZSBlbXVsYXRvciBob3N0IChleDogbG9jYWxob3N0KVxyXG4gICAgICogQHBhcmFtIHBvcnQgVGhlIGVtdWxhdG9yIHBvcnQgKGV4OiA1MDAxKVxyXG4gICAgICovXHJcbiAgICBTZXJ2aWNlLnByb3RvdHlwZS51c2VFbXVsYXRvciA9IGZ1bmN0aW9uIChob3N0LCBwb3J0KSB7XHJcbiAgICAgICAgdGhpcy5lbXVsYXRvck9yaWdpbiA9IFwiaHR0cDovL1wiICsgaG9zdCArIFwiOlwiICsgcG9ydDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhpcyBpbnN0YW5jZSB0byBwb2ludCB0byBhIENsb3VkIEZ1bmN0aW9ucyBlbXVsYXRvciBydW5uaW5nXHJcbiAgICAgKiBsb2NhbGx5LiBTZWUgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZnVuY3Rpb25zL2xvY2FsLWVtdWxhdG9yXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgUHJlZmVyIHRoZSB1c2VFbXVsYXRvcihob3N0LCBwb3J0KSBtZXRob2QuXHJcbiAgICAgKiBAcGFyYW0gb3JpZ2luIFRoZSBvcmlnaW4gb2YgdGhlIGxvY2FsIGVtdWxhdG9yLCBzdWNoIGFzXHJcbiAgICAgKiBcImh0dHA6Ly9sb2NhbGhvc3Q6NTAwNVwiLlxyXG4gICAgICovXHJcbiAgICBTZXJ2aWNlLnByb3RvdHlwZS51c2VGdW5jdGlvbnNFbXVsYXRvciA9IGZ1bmN0aW9uIChvcmlnaW4pIHtcclxuICAgICAgICB0aGlzLmVtdWxhdG9yT3JpZ2luID0gb3JpZ2luO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgY2FsbGFibGUgaHR0cHMgdHJpZ2dlciB3aXRoIHRoZSBnaXZlbiBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHRyaWdnZXIuXHJcbiAgICAgKi9cclxuICAgIFNlcnZpY2UucHJvdG90eXBlLmh0dHBzQ2FsbGFibGUgPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jYWxsKG5hbWUsIGRhdGEsIG9wdGlvbnMgfHwge30pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEb2VzIGFuIEhUVFAgUE9TVCBhbmQgcmV0dXJucyB0aGUgY29tcGxldGVkIHJlc3BvbnNlLlxyXG4gICAgICogQHBhcmFtIHVybCBUaGUgdXJsIHRvIHBvc3QgdG8uXHJcbiAgICAgKiBAcGFyYW0gYm9keSBUaGUgSlNPTiBib2R5IG9mIHRoZSBwb3N0LlxyXG4gICAgICogQHBhcmFtIGhlYWRlcnMgVGhlIEhUVFAgaGVhZGVycyB0byBpbmNsdWRlIGluIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQHJldHVybiBBIFByb21pc2UgdGhhdCB3aWxsIHN1Y2NlZWQgd2hlbiB0aGUgcmVxdWVzdCBmaW5pc2hlcy5cclxuICAgICAqL1xyXG4gICAgU2VydmljZS5wcm90b3R5cGUucG9zdEpTT04gPSBmdW5jdGlvbiAodXJsLCBib2R5LCBoZWFkZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIGVfMSwganNvbiwgZV8yO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5mZXRjaEltcGwodXJsLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGFuIHVuaGFuZGxlZCBlcnJvciBvbiB0aGUgYmFja2VuZCwgb3IgaXQgY291bGQgYmUgYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXR3b3JrIGVycm9yLiBUaGVyZSdzIG5vIHdheSB0byBrbm93LCBzaW5jZSBhbiB1bmhhbmRsZWQgZXJyb3Igb24gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhY2tlbmQgd2lsbCBmYWlsIHRvIHNldCB0aGUgcHJvcGVyIENPUlMgaGVhZGVyLCBhbmQgdGh1cyB3aWxsIGJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyZWF0ZWQgYXMgYSBuZXR3b3JrIGVycm9yIGJ5IGZldGNoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzUsIDcsICwgOF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNwb25zZS5qc29uKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlXzIgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjoganNvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxscyBhIGNhbGxhYmxlIGZ1bmN0aW9uIGFzeW5jaHJvbm91c2x5IGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY2FsbGFibGUgdHJpZ2dlci5cclxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHBhc3MgYXMgcGFyYW1zIHRvIHRoZSBmdW5jdGlvbi5zXHJcbiAgICAgKi9cclxuICAgIFNlcnZpY2UucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAobmFtZSwgZGF0YSwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgYm9keSwgaGVhZGVycywgY29udGV4dCwgdGltZW91dCwgX2EsIHRpbWVyLCBmYWlsQWZ0ZXJQcm9taXNlLCByZXNwb25zZSwgZXJyb3IsIHJlc3BvbnNlRGF0YSwgZGVjb2RlZERhdGE7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuX3VybChuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIGFueSBzcGVjaWFsIHR5cGVzLCBzdWNoIGFzIGRhdGVzLCBpbiB0aGUgaW5wdXQgZGF0YS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuc2VyaWFsaXplci5lbmNvZGUoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSB7IGRhdGE6IGRhdGEgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNvbnRleHRQcm92aWRlci5nZXRDb250ZXh0KCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuYXV0aFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSAnQmVhcmVyICcgKyBjb250ZXh0LmF1dGhUb2tlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5pbnN0YW5jZUlkVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0ZpcmViYXNlLUluc3RhbmNlLUlELVRva2VuJ10gPSBjb250ZXh0Lmluc3RhbmNlSWRUb2tlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDcwMDAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IGZhaWxBZnRlcih0aW1lb3V0KSwgdGltZXIgPSBfYS50aW1lciwgZmFpbEFmdGVyUHJvbWlzZSA9IF9hLnByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmFjZShbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0V3JhcHBlcih0aW1lciwgdGhpcy5wb3N0SlNPTih1cmwsIGJvZHksIGhlYWRlcnMpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsQWZ0ZXJQcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dFdyYXBwZXIodGltZXIsIHRoaXMuY2FuY2VsQWxsUmVxdWVzdHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgc2VydmljZSB3YXMgZGVsZXRlZCwgaW50ZXJydXB0ZWQgcmVzcG9uc2UgdGhyb3dzIGFuIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSHR0cHNFcnJvckltcGwoJ2NhbmNlbGxlZCcsICdGaXJlYmFzZSBGdW5jdGlvbnMgaW5zdGFuY2Ugd2FzIGRlbGV0ZWQuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBfZXJyb3JGb3JSZXNwb25zZShyZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLmpzb24sIHRoaXMuc2VyaWFsaXplcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5qc29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSHR0cHNFcnJvckltcGwoJ2ludGVybmFsJywgJ1Jlc3BvbnNlIGlzIG5vdCB2YWxpZCBKU09OIG9iamVjdC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZURhdGEgPSByZXNwb25zZS5qc29uLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oa2xpbXQpOiBGb3IgcmlnaHQgbm93LCBhbGxvdyBcInJlc3VsdFwiIGluc3RlYWQgb2YgXCJkYXRhXCIsIGZvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZURhdGEgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZURhdGEgPSByZXNwb25zZS5qc29uLnJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlRGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHRoZSByZXNwb25zZSBtYWxmb3JtZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSHR0cHNFcnJvckltcGwoJ2ludGVybmFsJywgJ1Jlc3BvbnNlIGlzIG1pc3NpbmcgZGF0YSBmaWVsZC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkRGF0YSA9IHRoaXMuc2VyaWFsaXplci5kZWNvZGUocmVzcG9uc2VEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgZGF0YTogZGVjb2RlZERhdGEgfV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTZXJ2aWNlO1xyXG59KCkpO1xyXG5mdW5jdGlvbiBjbGVhclRpbWVvdXRXcmFwcGVyKHRpbWVyLCBwcm9taXNlKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgcHJvbWlzZV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFR5cGUgY29uc3RhbnQgZm9yIEZpcmViYXNlIEZ1bmN0aW9ucy5cclxuICovXHJcbnZhciBGVU5DVElPTlNfVFlQRSA9ICdmdW5jdGlvbnMnO1xyXG5mdW5jdGlvbiByZWdpc3RlckZ1bmN0aW9ucyhpbnN0YW5jZSwgZmV0Y2hJbXBsKSB7XHJcbiAgICB2YXIgbmFtZXNwYWNlRXhwb3J0cyA9IHtcclxuICAgICAgICAvLyBuby1pbmxpbmVcclxuICAgICAgICBGdW5jdGlvbnM6IFNlcnZpY2VcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBmYWN0b3J5KGNvbnRhaW5lciwgcmVnaW9uT3JDdXN0b21Eb21haW4pIHtcclxuICAgICAgICAvLyBEZXBlbmRlbmNpZXNcclxuICAgICAgICB2YXIgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICB2YXIgYXV0aFByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhdXRoLWludGVybmFsJyk7XHJcbiAgICAgICAgdmFyIG1lc3NhZ2luZ1Byb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdtZXNzYWdpbmcnKTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHJldHVybiBuZXcgU2VydmljZShhcHAsIGF1dGhQcm92aWRlciwgbWVzc2FnaW5nUHJvdmlkZXIsIHJlZ2lvbk9yQ3VzdG9tRG9tYWluLCBmZXRjaEltcGwpO1xyXG4gICAgfVxyXG4gICAgaW5zdGFuY2UuSU5URVJOQUwucmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudChGVU5DVElPTlNfVFlQRSwgZmFjdG9yeSwgXCJQVUJMSUNcIiAvKiBQVUJMSUMgKi8pXHJcbiAgICAgICAgLnNldFNlcnZpY2VQcm9wcyhuYW1lc3BhY2VFeHBvcnRzKVxyXG4gICAgICAgIC5zZXRNdWx0aXBsZUluc3RhbmNlcyh0cnVlKSk7XHJcbn1cblxudmFyIG5hbWUgPSBcIkBmaXJlYmFzZS9mdW5jdGlvbnNcIjtcbnZhciB2ZXJzaW9uID0gXCIwLjYuMVwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5yZWdpc3RlckZ1bmN0aW9ucyhmaXJlYmFzZSwgZmV0Y2guYmluZChzZWxmKSk7XHJcbmZpcmViYXNlLnJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiIsImltcG9ydCAnQGZpcmViYXNlL2Z1bmN0aW9ucyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///590\n")}}]);